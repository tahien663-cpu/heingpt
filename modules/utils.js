// C·∫¨P NH·∫¨T: X√≥a MessageFlags v√¨ ƒë√£ d√πng ephemeral: true
const { EmbedBuilder, ActivityType, AttachmentBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');
const axios = require('axios');

// ==================== GAME HELPER ====================
/**
 * T√¨m game ƒëang ho·∫°t ƒë·ªông cho ng∆∞·ªùi d√πng trong k√™nh.
 * @param {Map} activeGames - Map c√°c game ƒëang ho·∫°t ƒë·ªông.
 * @param {string} userId - ID ng∆∞·ªùi d√πng.
 * @param {string} channelId - ID k√™nh.
 * @param {string} gameType - Lo·∫°i game (vd: 'numberguess', 'wordle').
 * @returns {Object|null} - Tr·∫£ v·ªÅ { gameId, game } n·∫øu t√¨m th·∫•y, ng∆∞·ª£c l·∫°i null.
 */
function findActiveGame(activeGames, userId, channelId, gameType) {
  for (const [gameId, game] of activeGames.entries()) {
    if (game.type === gameType && game.userId === userId && game.channelId === channelId) {
      return { gameId, game };
    }
  }
  return null;
}

// ==================== COMMAND HANDLERS ====================
async function handleChat(interaction, { conversationHistory, userProfiles, stats, callOpenRouter, addToHistory, getHistory, checkRateLimit, checkCooldown, getUserProfile, updateUserProfile }) {
  const message = interaction.options.getString('message');
  const userId = interaction.user.id;
  const channelId = interaction.channel.id;
  
  const rateCheck = checkRateLimit(userId, 'message');
  if (rateCheck.limited) {
    return interaction.reply({
      content: `‚è≥ Rate limit! ƒê·ª£i ${rateCheck.waitTime}s (Gi·ªõi h·∫°n: 20 tin/ph√∫t)`,
      ephemeral: true // C·∫¨P NH·∫¨T
    });
  }

  const cooldown = checkCooldown(userId);
  if (cooldown > 0) {
    return interaction.reply({
      content: `‚è≥ Cooldown ${cooldown}s`,
      ephemeral: true // C·∫¨P NH·∫¨T
    });
  }

  if (message.length > 500) {
    return interaction.reply({
      content: '‚ùå Tin nh·∫Øn qu√° d√†i! Gi·ªõi h·∫°n 500 k√Ω t·ª±.',
      ephemeral: true // C·∫¨P NH·∫¨T
    });
  }

  await interaction.deferReply();

  try {
    const profile = getUserProfile(userId);
    const history = getHistory(userId, channelId);
    
    addToHistory(userId, channelId, 'user', message);

    const response = await callOpenRouter(history);
    
    addToHistory(userId, channelId, 'assistant', response);
    stats.messagesProcessed++;
    profile.totalMessages++;
    updateUserProfile(userId, profile);

    // C·∫¨P NH·∫¨T: D√πng Embed cho tin nh·∫Øn d√†i ƒë·ªÉ nh·∫•t qu√°n v·ªõi handleMentionChat
    if (response.length > 2000) {
      const embed = new EmbedBuilder()
        .setColor('#0099ff')
        .setDescription(response.substring(0, 4096)) // Gi·ªõi h·∫°n Embed
        .setFooter({ text: `Replied to ${interaction.user.username}` });
      await interaction.editReply({ embeds: [embed] });
    } else {
      await interaction.editReply({ content: response });
    }

  } catch (error) {
    stats.errors++;
    console.error('Error:', error);
    
    const errorEmbed = new EmbedBuilder()
      .setColor('#FF0000')
      .setTitle('‚ùå L·ªói')
      .setDescription('Kh√¥ng th·ªÉ x·ª≠ l√Ω y√™u c·∫ßu. Th·ª≠ l·∫°i sau!')
      .setTimestamp();
    
    await interaction.editReply({ embeds: [errorEmbed] });
  }
}

async function handleReset(interaction, { conversationHistory, getHistoryKey }) {
  const key = getHistoryKey(interaction.user.id, interaction.channel.id);
  conversationHistory.delete(key);
  
  await interaction.reply({
    embeds: [new EmbedBuilder()
      .setColor('#00FF00')
      .setTitle('‚úÖ Reset th√†nh c√¥ng')
      .setDescription('ƒê√£ x√≥a l·ªãch s·ª≠ h·ªôi tho·∫°i!')
      .setTimestamp()]
  });
}

async function handlePersonality(interaction, { PERSONALITIES, userProfiles, updateUserProfile, conversationHistory, getHistoryKey, stats }) {
  const newPersonality = interaction.options.getString('type');
  
  if (!PERSONALITIES[newPersonality]) {
    return interaction.reply({
      content: '‚ùå Personality kh√¥ng t·ªìn t·∫°i!',
      ephemeral: true // C·∫¨P NH·∫¨T
    });
  }

  updateUserProfile(interaction.user.id, { personality: newPersonality });
  const key = getHistoryKey(interaction.user.id, interaction.channel.id);
  conversationHistory.delete(key); // Reset history khi ƒë·ªïi personality
  stats.personalityChanges++;

  const selected = PERSONALITIES[newPersonality];
  
  // L·∫•y prompt g·ªëc (kh√¥ng c√≥ base system prompt) ƒë·ªÉ hi·ªÉn th·ªã cho user
  const displayPrompt = selected.prompt.split('\n\nPERSONALITY DETAILS:\n')[1] || selected.prompt;

  await interaction.reply({
    embeds: [new EmbedBuilder()
      .setColor('#00FF00')
      .setTitle('‚úÖ ƒê·ªïi personality th√†nh c√¥ng')
      // C·∫¨P NH·∫¨T: Hi·ªÉn th·ªã prompt g·ªëc s·∫°ch s·∫Ω h∆°n
      .setDescription(`**${selected.emoji} ${selected.name}**\n*${displayPrompt.split('\n')[0]}*`)
      .setFooter({ text: 'L·ªãch s·ª≠ chat ƒë√£ ƒë∆∞·ª£c reset' })
      .setTimestamp()]
  });
}

// C·∫¨P NH·∫¨T: Th√™m IMAGE_MODEL v√†o dependencies
async function handleImage(interaction, { stats, checkRateLimit, checkCooldown, getUserProfile, updateUserProfile, enhanceImagePrompt, generateImage, IMAGE_MODEL }) {
  const prompt = interaction.options.getString('prompt');
  const style = interaction.options.getString('style') || 'realistic';
  
  const imgRateCheck = checkRateLimit(interaction.user.id, 'image');
  if (imgRateCheck.limited) {
    return interaction.reply({
      content: `‚è≥ Rate limit! ƒê·ª£i ${imgRateCheck.waitTime}s (Gi·ªõi h·∫°n: 8 ·∫£nh/ph√∫t)`,
      ephemeral: true // C·∫¨P NH·∫¨T
    });
  }

  const imgCooldown = checkCooldown(interaction.user.id);
  if (imgCooldown > 0) {
    return interaction.reply({
      content: `‚è≥ ƒê·ª£i ${imgCooldown}s`,
      ephemeral: true // C·∫¨P NH·∫¨T
    });
  }

  const userProfile = getUserProfile(interaction.user.id);

  const processingEmbed = new EmbedBuilder()
    .setColor('#FFA500')
    .setTitle('üé® ƒêang t·∫°o ·∫£nh...')
    .setDescription(`**M√¥ t·∫£:** ${prompt}\n**Style:** ${style}`)
    .setFooter({ text: 'ƒêang x·ª≠ l√Ω...' })
    .setTimestamp();
  
  await interaction.reply({ embeds: [processingEmbed] });

  try {
    const enhancedPrompt = await enhanceImagePrompt(prompt, style);
    
    processingEmbed
      .setDescription(`**M√¥ t·∫£:** ${prompt}\n**Style:** ${style}\n**Prompt:** ${enhancedPrompt.substring(0, 1000)}...`)
      .setFooter({ text: 'ƒêang render... (10-60s)' });
    await interaction.editReply({ embeds: [processingEmbed] });

    const imageData = await generateImage(enhancedPrompt, { width: 1024, height: 1024 });
    
    stats.imagesGenerated++;
    userProfile.totalImages++;
    updateUserProfile(interaction.user.id, userProfile);

    const attachment = new AttachmentBuilder(imageData.buffer, { name: 'ai_generated.png' });

    await interaction.editReply({ 
      embeds: [new EmbedBuilder()
        .setColor('#00FF00')
        .setTitle('‚úÖ ·∫¢nh ho√†n th√†nh!')
        .addFields(
          { name: 'üìù Y√™u c·∫ßu', value: prompt },
          { name: 'üé® Style', value: style, inline: true },
          // C·∫¨P NH·∫¨T: Hi·ªÉn th·ªã prompt ƒë√£ ƒë∆∞·ª£c enhance (gi·ªõi h·∫°n 1024 k√Ω t·ª±)
          { name: 'ü§ñ Prompt (Enhanced)', value: enhancedPrompt.substring(0, 1020) + '...' }
        )
        .setImage('attachment://ai_generated.png')
        // C·∫¨P NH·∫¨T: S·ª≠a footer, hi·ªÉn th·ªã ƒë√∫ng model ƒëang d√πng
        .setFooter({ text: `By ${interaction.user.tag} ‚Ä¢ Model: ${IMAGE_MODEL}` })
        .setTimestamp()],
      files: [attachment]
    });

  } catch (error) {
    console.error('Image error:', error);
    stats.errors++;
    
    await interaction.editReply({ embeds: [new EmbedBuilder()
      .setColor('#FF0000')
      .setTitle('‚ùå L·ªói t·∫°o ·∫£nh')
      .setDescription(error.message || 'Kh√¥ng th·ªÉ t·∫°o ·∫£nh. Th·ª≠ l·∫°i sau!')
      .setTimestamp()] });
  }
}

async function handleImagine(interaction, { stats, checkRateLimit, enhanceImagePrompt, generateImage }) {
  const prompt = interaction.options.getString('prompt');
  
  const imagineRateCheck = checkRateLimit(interaction.user.id, 'image');
  if (imagineRateCheck.limited) {
    return interaction.reply({
      content: `‚è≥ Rate limit! ƒê·ª£i ${imagineRateCheck.waitTime}s`,
      ephemeral: true // C·∫¨P NH·∫¨T
    });
  }

  // C·∫¨P NH·∫¨T: D√πng deferReply thay v√¨ reply
  await interaction.deferReply({ content: 'üé® ƒêang t·∫°o 4 phi√™n b·∫£n kh√°c nhau...' });

  try {
    const styles = ['realistic', 'anime', 'artistic', 'cyberpunk'];
    const promises = styles.map(async (style) => {
      const enhanced = await enhanceImagePrompt(prompt, style);
      // Gi·ªØ 512x512 cho imagine ƒë·ªÉ load nhanh h∆°n
      return generateImage(enhanced, { width: 512, height: 512 });
    });

    const results = await Promise.all(promises);
    
    const attachments = results.map((result, idx) => 
      new AttachmentBuilder(result.buffer, { name: `variant_${idx + 1}.png` })
    );

    stats.imagesGenerated += 4;

    // C·∫¨P NH·∫¨T: D√πng editReply
    await interaction.editReply({
      content: '‚úÖ 4 phi√™n b·∫£n ƒë√£ ho√†n th√†nh!',
      embeds: [new EmbedBuilder()
        .setColor('#9B59B6')
        .setTitle('‚ú® 4 Phi√™n b·∫£n')
        .setDescription(`**Prompt:** ${prompt}`)
        .addFields(
          { name: '1Ô∏è‚É£ Realistic', value: 'Ch√¢n th·ª±c', inline: true },
          { name: '2Ô∏è‚É£ Anime', value: 'Phong c√°ch Nh·∫≠t', inline: true },
          { name: '3Ô∏è‚É£ Artistic', value: 'Ngh·ªá thu·∫≠t', inline: true },
          { name: '4Ô∏è‚É£ Cyberpunk', value: 'T∆∞∆°ng lai', inline: true }
        )
        .setFooter({ text: `${interaction.user.tag}` })
        .setTimestamp()],
      files: attachments
    });

  } catch (error) {
    console.error('Imagine error:', error);
    stats.errors++;
    await interaction.editReply('‚ùå L·ªói t·∫°o ·∫£nh! Models c√≥ th·ªÉ ƒëang b·∫≠n, vui l√≤ng th·ª≠ l·∫°i sau.');
  }
}

async function handleProfile(interaction, { userProfiles, PERSONALITIES, getUserProfile }) {
  // C·∫¨P NH·∫¨T: D√πng getUserProfile t·ª´ dependencies
  const userProfile = getUserProfile(interaction.user.id);
  const personality = PERSONALITIES[userProfile.personality] || PERSONALITIES.default;
  const joinedDate = new Date(userProfile.createdAt).toLocaleDateString('vi-VN');

  await interaction.reply({
    embeds: [new EmbedBuilder()
      .setColor('#3498DB')
      .setTitle(`üë§ Profile: ${interaction.user.username}`)
      .setThumbnail(interaction.user.displayAvatarURL())
      .addFields(
        { name: 'üé≠ Personality', value: `${personality.emoji} ${personality.name}`, inline: true },
        { name: 'üåê Ng√¥n ng·ªØ', value: (userProfile.language || 'auto').toUpperCase(), inline: true },
        { name: 'üé® Style ·∫£nh', value: userProfile.imageStyle || 'realistic', inline: true },
        { name: 'üí¨ Tin nh·∫Øn', value: `${userProfile.totalMessages}`, inline: true },
        { name: 'üñºÔ∏è ·∫¢nh t·∫°o', value: `${userProfile.totalImages}`, inline: true },
        { name: 'üìÖ Tham gia', value: joinedDate, inline: true },
        { name: 'üåç V·ªã tr√≠ th·ªùi ti·∫øt', value: userProfile.weatherLocation || 'Hanoi', inline: true },
        { name: 'üéÆ Tr√≤ ch∆°i ƒë√£ ch∆°i', value: `${userProfile.gamesPlayed || 0}`, inline: true }
      )
      .setFooter({ text: 'D√πng /personality ƒë·ªÉ ƒë·ªïi AI' })
      .setTimestamp()]
  });
}

async function handleLeaderboard(interaction, { userProfiles }) {
  const topUsers = Array.from(userProfiles.entries())
    .sort((a, b) => (b[1].totalMessages || 0) - (a[1].totalMessages || 0))
    .slice(0, 10);

  await interaction.reply({
    embeds: [new EmbedBuilder()
      .setColor('#FFD700')
      .setTitle('üèÜ Leaderboard - Top Users')
      .setDescription(
        topUsers.length === 0 
          ? 'Ch∆∞a c√≥ d·ªØ li·ªáu' 
          : topUsers.map(([userId, profile], idx) => {
              const medals = ['ü•á', 'ü•à', 'ü•â'];
              const medal = medals[idx] || `${idx + 1}.`;
              // C·∫¨P NH·∫¨T: Th√™m fallback 0
              return `${medal} <@${userId}>: ${profile.totalMessages || 0} tin, ${profile.totalImages || 0} ·∫£nh`;
            }).join('\n')
      )
      .setFooter({ text: 'D·ª±a tr√™n s·ªë tin nh·∫Øn' })
      .setTimestamp()]
  });
}

async function handleStats(interaction, { stats, conversationHistory, userProfiles, commandUsage, CURRENT_API_PROVIDER }) {
  const totalConversations = conversationHistory.size;
  const totalUsers = userProfiles.size;
  const uptime = Date.now() - stats.startTime;
  const days = Math.floor(uptime / 86400000);
  const hours = Math.floor((uptime % 86400000) / 3600000);
  const minutes = Math.floor((uptime % 3600000) / 60000);
  const successRate = stats.messagesProcessed > 0
    ? ((stats.messagesProcessed - stats.errors) / stats.messagesProcessed * 100).toFixed(2)
    : 100;

  const topCommands = Array.from(commandUsage.entries())
    .sort((a, b) => b[1] - a[1])
    .slice(0, 5)
    .map(([cmd, count]) => `\`/${cmd}\`: ${count}`) // Th√™m /
    .join('\n');

  const apiStatus = Object.entries(stats.apiFailures).map(([provider, failures]) => {
    const status = failures === 0 ? 'üü¢' : failures < 5 ? 'üü°' : 'üî¥';
    return `${status} ${provider.charAt(0).toUpperCase() + provider.slice(1)}: ${failures} failures`;
  }).join('\n');

  const keyFailuresSummary = Object.entries(stats.keyFailures).map(([provider, keys]) => {
    const totalKeyFailures = Object.values(keys).reduce((sum, count) => sum + count, 0);
    return `${provider}: ${totalKeyFailures} key failures`;
  }).join('\n') || 'No key failures';

  await interaction.reply({
    embeds: [new EmbedBuilder()
      .setColor('#E74C3C')
      .setTitle('üìä Th·ªëng k√™ Bot')
      .addFields(
        { name: 'üí¨ Tin nh·∫Øn', value: `${stats.messagesProcessed}`, inline: true },
        { name: 'üé® ·∫¢nh t·∫°o', value: `${stats.imagesGenerated}`, inline: true },
        { name: '‚ö° L·ªánh', value: `${stats.commandsUsed}`, inline: true },
        { name: '‚ùå L·ªói', value: `${stats.errors}`, inline: true },
        { name: '‚úÖ Success rate', value: `${successRate}%`, inline: true },
        // C·∫¨P NH·∫¨T: Hi·ªÉn th·ªã ng√†y
        { name: '‚è±Ô∏è Uptime', value: `${days}d ${hours}h ${minutes}m`, inline: true },
        { name: 'üë• Users', value: `${totalUsers}`, inline: true },
        { name: 'üí¨ Conversations', value: `${totalConversations}`, inline: true },
        { name: 'üé≠ Personality switches', value: `${stats.personalityChanges}`, inline: true },
        { name: 'üå§Ô∏è Truy v·∫•n th·ªùi ti·∫øt', value: `${stats.weatherQueries}`, inline: true },
        { name: 'üéÆ Tr√≤ ch∆°i ch∆°i', value: `${stats.gamesPlayed}`, inline: true },
        { name: 'üîÑ Model switches', value: `${stats.modelSwitches}`, inline: true },
        { name: 'üî• Top Commands', value: topCommands || 'Ch∆∞a c√≥' },
        { name: 'ü§ñ API Provider', value: `Current: **${CURRENT_API_PROVIDER.current}**\n\n${apiStatus}` },
        { name: 'üîë Key Failures', value: keyFailuresSummary }
      )
      .setFooter({ text: 'T·ª´ l·∫ßn restart cu·ªëi' })
      .setTimestamp()]
  });
}

async function handleTranslate(interaction, { callOpenRouter }) {
  const text = interaction.options.getString('text');
  
  await interaction.deferReply();

  try {
    const translatePrompt = [
      { role: 'system', content: 'You are an expert translator. Detect the user language. If it is English, translate to Vietnamese. If it is Vietnamese, translate to English. ONLY return the translation, no explanations.' },
      { role: 'user', content: text }
    ];

    const translation = await callOpenRouter(translatePrompt, { maxTokens: 500, temperature: 0.1 });

    await interaction.editReply({
      embeds: [new EmbedBuilder()
        .setColor('#3498DB')
        .setTitle('üåê D·ªãch thu·∫≠t')
        .addFields(
          // C·∫¨P NH·∫¨T: Gi·ªõi h·∫°n 1024 k√Ω t·ª±
          { name: 'üìù G·ªëc', value: text.substring(0, 1020) + '...' },
          { name: '‚úÖ D·ªãch', value: translation.substring(0, 1020) + '...' }
        )
        .setTimestamp()]
    });
  } catch (error) {
    console.error('Translate error:', error);
    await interaction.editReply('‚ùå L·ªói d·ªãch thu·∫≠t!');
  }
}

async function handleSummary(interaction, { callOpenRouter }) {
  const text = interaction.options.getString('text');
  
  if (text.length < 100) {
    return interaction.reply({
      content: '‚ùå Text qu√° ng·∫Øn ƒë·ªÉ t√≥m t·∫Øt (c·∫ßn >100 k√Ω t·ª±)',
      ephemeral: true // C·∫¨P NH·∫¨T
    });
  }

  await interaction.deferReply();

  try {
    const summaryPrompt = [
      { role: 'system', content: 'B·∫°n l√† chuy√™n gia t√≥m t·∫Øt vƒÉn b·∫£n. T√≥m t·∫Øt ng·∫Øn g·ªçn (3-5 c√¢u), gi·ªØ √Ω ch√≠nh, d√πng ti·∫øng Vi·ªát.' },
      { role: 'user', content: text }
    ];

    const summary = await callOpenRouter(summaryPrompt, { maxTokens: 400 });

    await interaction.editReply({
      embeds: [new EmbedBuilder()
        .setColor('#9B59B6')
        .setTitle('üìã T√≥m t·∫Øt')
        .addFields(
          { name: 'üìÑ G·ªëc', value: text.substring(0, 1020) + '...' },
          { name: '‚ú® T√≥m t·∫Øt', value: summary }
        )
        .setFooter({ text: `${text.length} ‚Üí ${summary.length} k√Ω t·ª±` })
        .setTimestamp()]
    });
  } catch (error) {
    console.error('Summary error:', error);
    await interaction.editReply('‚ùå L·ªói t√≥m t·∫Øt!');
  }
}

async function handleCode(interaction, { callOpenRouter }) {
  const request = interaction.options.getString('request');
  
  await interaction.deferReply();

  try {
    const codePrompt = [
      // C·∫¨P NH·∫¨T: Cho ph√©p markdown cho code
      { role: 'system', content: 'You are a 10-year+ Senior Developer. Write clean, commented code. Explain briefly. Use markdown code blocks for code. Respond in the user\'s language.' },
      { role: 'user', content: request }
    ];

    // C·∫¨P NH·∫¨T: TƒÉng maxTokens cho code
    const codeResponse = await callOpenRouter(codePrompt, { maxTokens: 1500, temperature: 0.2 });

    if (codeResponse.length > 2000) {
      // G·ª≠i ph·∫ßn ƒë·∫ßu
      await interaction.editReply({ content: codeResponse.substring(0, 2000) });
      // G·ª≠i ph·∫ßn c√≤n l·∫°i
      for (let i = 2000; i < codeResponse.length; i += 2000) {
        await interaction.followUp({ content: codeResponse.substring(i, i + 2000) });
      }
    } else {
      await interaction.editReply({ content: codeResponse });
    }
  } catch (error) {
    console.error('Code error:', error);
    await interaction.editReply('‚ùå L·ªói t·∫°o code!');
  }
}

async function handleQuiz(interaction, { callOpenRouter }) {
  const topic = interaction.options.getString('topic') || 'ki·∫øn th·ª©c t·ªïng qu√°t';
  
  await interaction.deferReply();

  try {
    const quizPrompt = [
      { role: 'system', content: 'T·∫°o 1 c√¢u h·ªèi tr·∫Øc nghi·ªám ti·∫øng Vi·ªát v·ªõi 4 ƒë√°p √°n A, B, C, D. Format:\nüéØ C√¢u h·ªèi: [c√¢u h·ªèi]\nA) ...\nB) ...\nC) ...\nD) ...\n\n**ƒê√°p √°n ƒë√∫ng:** X\n**Gi·∫£i th√≠ch:** ...' },
      { role: 'user', content: `T·∫°o c√¢u h·ªèi v·ªÅ: ${topic}` }
    ];

    const quiz = await callOpenRouter(quizPrompt, { maxTokens: 400, temperature: 0.8 });

    await interaction.editReply({
      embeds: [new EmbedBuilder()
        .setColor('#F39C12')
        .setTitle('üéØ Quiz Time!')
        .setDescription(quiz)
        .setFooter({ text: `Ch·ªß ƒë·ªÅ: ${topic} ‚Ä¢ /quiz [ch·ªß ƒë·ªÅ] ƒë·ªÉ t·∫°o m·ªõi` })
        .setTimestamp()]
    });
  } catch (error) {
    console.error('Quiz error:', error);
    await interaction.editReply('‚ùå L·ªói t·∫°o quiz!');
  }
}

async function handleJoke(interaction, { callOpenRouter }) {
  await interaction.deferReply();

  try {
    const jokePrompt = [
      { role: 'system', content: 'K·ªÉ 1 c√¢u chuy·ªán c∆∞·ªùi ti·∫øng Vi·ªát ng·∫Øn g·ªçn, h√†i h∆∞·ªõc, l√†nh m·∫°nh (ch·ªß ƒë·ªÅ l·∫≠p tr√¨nh, vƒÉn ph√≤ng, ho·∫∑c ch∆°i ch·ªØ).' },
      { role: 'user', content: 'K·ªÉ tao m·ªôt c√¢u chuy·ªán c∆∞·ªùi' }
    ];

    const joke = await callOpenRouter(jokePrompt, { maxTokens: 300, temperature: 0.9 });

    await interaction.editReply({
      embeds: [new EmbedBuilder()
        .setColor('#E67E22')
        .setTitle('üòÑ Chuy·ªán c∆∞·ªùi')
        .setDescription(joke)
        .setFooter({ text: 'D√πng /joke ƒë·ªÉ nghe th√™m' })
        .setTimestamp()]
    });
  } catch (error) {
    console.error('Joke error:', error);
    await interaction.editReply('‚ùå H·∫øt chuy·ªán ƒë·ªÉ k·ªÉ r·ªìi üòÖ');
  }
}

async function handleFact(interaction, { callOpenRouter }) {
  await interaction.deferReply();

  try {
    const factPrompt = [
      { role: 'system', content: 'ƒê∆∞a ra 1 fact th√∫ v·ªã, √≠t ng∆∞·ªùi bi·∫øt. Ng·∫Øn g·ªçn 2-3 c√¢u, ti·∫øng Vi·ªát.' },
      { role: 'user', content: 'Cho t√¥i m·ªôt fact th√∫ v·ªã' }
    ];

    const fact = await callOpenRouter(factPrompt, { maxTokens: 200, temperature: 0.8 });

    await interaction.editReply({
      embeds: [new EmbedBuilder()
        .setColor('#1ABC9C')
        .setTitle('üí° Fact th√∫ v·ªã')
        .setDescription(fact)
        .setFooter({ text: 'D√πng /fact ƒë·ªÉ xem th√™m' })
        .setTimestamp()]
    });
  } catch (error) {
    console.error('Fact error:', error);
    await interaction.editReply('‚ùå L·ªói l·∫•y fact!');
  }
}

async function handleRemind(interaction) {
  const timeArg = interaction.options.getString('time');
  const reminderMsg = interaction.options.getString('message');

  const timeMatch = timeArg.match(/^(\d+)([smh])$/);
  if (!timeMatch) {
    return interaction.reply({
      content: '‚ùå Th·ªùi gian kh√¥ng h·ª£p l·ªá! D√πng: 30s, 5m, 2h',
      ephemeral: true // C·∫¨P NH·∫¨T
    });
  }

  const [, value, unit] = timeMatch;
  const multiplier = { s: 1000, m: 60000, h: 3600000 }[unit];
  const delay = parseInt(value) * multiplier;

  if (delay > 86400000) { // 24 gi·ªù
    return interaction.reply({
      content: '‚ùå Th·ªùi gian t·ªëi ƒëa: 24h',
      ephemeral: true // C·∫¨P NH·∫¨T
    });
  }

  await interaction.reply({
    embeds: [new EmbedBuilder()
      .setColor('#27AE60')
      .setTitle('‚è∞ Reminder ƒë√£ ƒë·∫∑t')
      .setDescription(`S·∫Ω nh·∫Øc sau **${value}${unit}**:\n${reminderMsg}`)
      .setTimestamp()],
    ephemeral: true // C·∫¨P NH·∫¨T: Ch·ªâ ng∆∞·ªùi ƒë·∫∑t m·ªõi th·∫•y
  });

  setTimeout(async () => {
    try {
      // C·∫¨P NH·∫¨T: G·ª≠i tin nh·∫Øn m·ªõi thay v√¨ followUp (v√¨ followUp c√≥ th·ªÉ fail n·∫øu interaction g·ªëc qu√° c≈©)
      await interaction.channel.send({ 
        content: `<@${interaction.user.id}>`,
        embeds: [new EmbedBuilder()
          .setColor('#E67E22')
          .setTitle('üîî Reminder!')
          .setDescription(reminderMsg)
          .setFooter({ text: `ƒê√£ ƒë·∫∑t ${value}${unit} tr∆∞·ªõc` })
          .setTimestamp()]
      });
    } catch (error) {
      console.error('Reminder send error:', error);
      // Th·ª≠ g·ª≠i DM n·∫øu kh√¥ng g·ª≠i ƒë∆∞·ª£c v√†o k√™nh
      try {
        await interaction.user.send({
          embeds: [new EmbedBuilder()
            .setColor('#E67E22')
            .setTitle('üîî Reminder!')
            .setDescription(reminderMsg)
            .setFooter({ text: `ƒê√£ ƒë·∫∑t ${value}${unit} tr∆∞·ªõc t·∫°i k√™nh #${interaction.channel.name}` })
            .setTimestamp()]
        });
      } catch (dmError) {
        console.error('Reminder DM error:', dmError);
      }
    }
  }, delay);
}

// (C√°c h√†m game gi·∫£i tr√≠ handleRoll, handleFlip, handleRPS gi·ªØ nguy√™n)
async function handleRoll(interaction) {
  const sides = interaction.options.getInteger('sides') || 6;
  const result = Math.floor(Math.random() * sides) + 1;

  await interaction.reply({
    embeds: [new EmbedBuilder()
      .setColor('#9B59B6')
      .setTitle('üé≤ Roll Dice')
      .setDescription(`**K·∫øt qu·∫£:** ${result} / ${sides}`)
      .setFooter({ text: `${interaction.user.username} rolled` })
      .setTimestamp()]
  });
}

async function handleFlip(interaction) {
  const result = Math.random() < 0.5 ? 'NG·ª¨A ü™ô' : 'S·∫§P üé¥';

  await interaction.reply({
    embeds: [new EmbedBuilder()
      .setColor('#F1C40F')
      .setTitle('ü™ô Toss Coin')
      .setDescription(`**K·∫øt qu·∫£:** ${result}`)
      .setFooter({ text: `${interaction.user.username} tossed` })
      .setTimestamp()]
  });
}

async function handleRPS(interaction, { stats }) {
  const choices = ['rock', 'paper', 'scissors'];
  const emojis = { rock: '‚úä', paper: '‚úã', scissors: '‚úåÔ∏è' };
  const userChoice = interaction.options.getString('choice');
  const botChoice = choices[Math.floor(Math.random() * choices.length)];
  
  let result;
  if (userChoice === botChoice) {
    result = 'H√≤a!';
  } else if (
    (userChoice === 'rock' && botChoice === 'scissors') ||
    (userChoice === 'paper' && botChoice === 'rock') ||
    (userChoice === 'scissors' && botChoice === 'paper')
  ) {
    result = 'B·∫°n th·∫Øng!';
  } else {
    result = 'Bot th·∫Øng!';
  }
  
  stats.gamesPlayed++;
  
  await interaction.reply({
    embeds: [new EmbedBuilder()
      .setColor('#3498DB')
      .setTitle('‚úä O·∫≥n T√π T√¨')
      .addFields(
        { name: 'B·∫°n ch·ªçn', value: `${emojis[userChoice]} ${userChoice}`, inline: true },
        { name: 'Bot ch·ªçn', value: `${emojis[botChoice]} ${botChoice}`, inline: true },
        { name: 'K·∫øt qu·∫£', value: result, inline: true }
      )
      .setTimestamp()]
  });
}
// (C√°c h√†m game ph·ª©c t·∫°p handle...Game gi·ªØ nguy√™n)
async function handleNumberGuess(interaction, { activeGames, stats }) {
  const number = Math.floor(Math.random() * 100) + 1;
  const gameId = `numberguess_${interaction.user.id}_${Date.now()}`;
  
  activeGames.set(gameId, {
    type: 'numberguess',
    number: number,
    attempts: 0,
    maxAttempts: 7,
    userId: interaction.user.id,
    channelId: interaction.channel.id,
    createdAt: Date.now()
  });
  
  await interaction.reply({
    embeds: [new EmbedBuilder()
      .setColor('#E74C3C')
      .setTitle('üî¢ ƒêo√°n S·ªë (1-100)')
      .setDescription('T√¥i ƒë√£ nghƒ© m·ªôt s·ªë t·ª´ 1-100. H√£y ƒëo√°n xem!')
      .addFields(
        { name: 'C√°ch ch∆°i', value: 'S·ª≠ d·ª•ng `/guess [s·ªë]` ƒë·ªÉ ƒëo√°n s·ªë' },
        { name: 'L∆∞·ª£t ƒëo√°n', value: '0/7' }
      )
      .setFooter({ text: `Game ID: ${gameId}` })
      .setTimestamp()]
  });
  
  stats.gamesPlayed++;
}

async function handleWordle(interaction, { activeGames, stats }) {
  // Wordlist ƒë√£ b·ªã x√≥a, b·∫°n c·∫ßn ƒë·∫£m b·∫£o n√≥ ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a ·ªü ƒë√¢u ƒë√≥
  // T·∫°m th·ªùi d√πng 1 list nh·ªè
  const words = ['APPLE', 'BRAVO', 'CREAM', 'DRIVE', 'EAGLE', 'FANCY', 'GREAT', 'HOUSE', 'INPUT', 'JOKER', 'LEMON', 'MAGIC', 'NINJA', 'OCEAN', 'POWER', 'QUIET', 'RADIO', 'SUPER', 'TIGER', 'ULTRA', 'VOICE', 'WATER', 'ZEBRA'];
  
  const word = words[Math.floor(Math.random() * words.length)];
  const gameId = `wordle_${interaction.user.id}_${Date.now()}`;
  
  activeGames.set(gameId, {
    type: 'wordle',
    word: word,
    attempts: [],
    maxAttempts: 6,
    userId: interaction.user.id,
    channelId: interaction.channel.id,
    createdAt: Date.now()
  });
  
  await interaction.reply({
    embeds: [new EmbedBuilder()
      .setColor('#2ECC71')
      .setTitle('üìù Wordle Game')
      .setDescription('ƒêo√°n t·ª´ ti·∫øng Anh 5 ch·ªØ c√°i!')
      .addFields(
        { name: 'C√°ch ch∆°i', value: 'üü© Ch·ªØ ƒë√∫ng, ƒë√∫ng v·ªã tr√≠\nüü® Ch·ªØ ƒë√∫ng, sai v·ªã tr√≠\n‚¨õ Kh√¥ng c√≥ trong t·ª´' },
        { name: 'L∆∞·ª£t ƒëo√°n', value: '0/6 \n\nS·ª≠ d·ª•ng `/wordleguess [t·ª´]` ƒë·ªÉ ƒëo√°n.' }
      )
      .setFooter({ text: `Game ID: ${gameId}` })
      .setTimestamp()]
  });
  
  stats.gamesPlayed++;
}

async function handleMemoryGame(interaction, { activeGames, stats }) {
  const emojis = ['üçé', 'üçå', 'üçá', 'üçì', 'üçí', 'üçë', 'üçâ', 'ü•ù']; // 8 c·∫∑p
  let pairs = [...emojis, ...emojis]; // 16 th·∫ª
  
  // Shuffle
  for (let i = pairs.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [pairs[i], pairs[j]] = [pairs[j], pairs[i]];
  }
  
  const gameId = `memory_${interaction.user.id}_${Date.now()}`;
  
  activeGames.set(gameId, {
    type: 'memory',
    cards: pairs,
    revealed: [], // Ch·ªâ l∆∞u index c·ªßa th·∫ª ƒëang l·∫≠t
    matched: new Array(16).fill(false),
    attempts: 0,
    userId: interaction.user.id,
    channelId: interaction.channel.id,
    createdAt: Date.now()
  });
  
  // T·∫°o b·∫£ng (d√πng button)
  const components = [];
  for (let r = 0; r < 4; r++) {
    const row = new ActionRowBuilder();
    for (let c = 0; c < 4; c++) {
      const index = r * 4 + c;
      row.addComponents(
        new ButtonBuilder()
          .setCustomId(`memory_${index}`)
          .setLabel('‚ùì')
          .setStyle(ButtonStyle.Secondary)
      );
    }
    components.push(row);
  }
  
  await interaction.reply({
    embeds: [new EmbedBuilder()
      .setColor('#9B59B6')
      .setTitle('üß† Memory Game')
      .setDescription('T√¨m t·∫•t c·∫£ c√°c c·∫∑p emoji gi·ªëng nhau!')
      .setFooter({ text: `Game ID: ${gameId}` })
      .setTimestamp()],
    components: components
  });
  
  stats.gamesPlayed++;
}

async function handleTicTacToe(interaction, { activeGames, stats }) {
  const gameId = `tictactoe_${interaction.user.id}_${Date.now()}`;
  
  activeGames.set(gameId, {
    type: 'tictactoe',
    board: Array(9).fill(''),
    currentPlayer: 'X', // X l√† ng∆∞·ªùi ch∆°i
    userId: interaction.user.id,
    channelId: interaction.channel.id,
    createdAt: Date.now()
  });
  
  const components = [];
  for (let r = 0; r < 3; r++) {
    const row = new ActionRowBuilder();
    for (let c = 0; c < 3; c++) {
      const index = r * 3 + c;
      row.addComponents(
        new ButtonBuilder()
          .setCustomId(`tictactoe_${index}`)
          .setLabel(' ') // Label tr·ªëng
          .setStyle(ButtonStyle.Secondary)
      );
    }
    components.push(row);
  }
  
  await interaction.reply({
    embeds: [new EmbedBuilder()
      .setColor('#3498DB')
      .setTitle('‚≠ï Tic Tac Toe')
      .setDescription('B·∫°n l√† X. L∆∞·ª£t c·ªßa b·∫°n!')
      .setFooter({ text: `Game ID: ${gameId}` })
      .setTimestamp()],
    components: components
  });
  
  stats.gamesPlayed++;
}

async function handleTrivia(interaction, { callOpenRouter, stats }) {
  // (Gi·ªØ nguy√™n)
  const category = interaction.options.getString('category') || 'general knowledge';
  
  await interaction.deferReply();
  
  try {
    const triviaPrompt = [
      { role: 'system', content: `T·∫°o 1 c√¢u h·ªèi tr·∫Øc nghi·ªám ti·∫øng Vi·ªát (ch·ªß ƒë·ªÅ ${category}) v·ªõi 4 ƒë√°p √°n A, B, C, D. Format:\nüéØ C√¢u h·ªèi: [c√¢u h·ªèi]\nA) ...\nB) ...\nC) ...\nD) ...\n\n**ƒê√°p √°n ƒë√∫ng:** X\n**Gi·∫£i th√≠ch:** ...` },
      { role: 'user', content: `T·∫°o c√¢u h·ªèi v·ªÅ: ${category}` }
    ];

    const trivia = await callOpenRouter(triviaPrompt, { maxTokens: 400, temperature: 0.8 });

    await interaction.editReply({
      embeds: [new EmbedBuilder()
        .setColor('#E74C3C')
        .setTitle('üß† Trivia Quiz')
        .setDescription(trivia)
        .setFooter({ text: `Ch·ªß ƒë·ªÅ: ${category} ‚Ä¢ /trivia [ch·ªß ƒë·ªÅ] ƒë·ªÉ t·∫°o m·ªõi` })
        .setTimestamp()]
    });
    
    stats.gamesPlayed++;
  } catch (error) {
    console.error('Trivia error:', error);
    await interaction.editReply('‚ùå L·ªói t·∫°o c√¢u h·ªèi trivia!');
  }
}

async function handleHangman(interaction, { activeGames, stats }) {
  // (Gi·ªØ nguy√™n)
  const words = {
    easy: ['CAT', 'DOG', 'SUN', 'MOON', 'STAR', 'TREE', 'BOOK', 'FISH', 'BIRD', 'HOME'],
    medium: ['HOUSE', 'WATER', 'PHONE', 'MUSIC', 'HAPPY', 'DREAM', 'LIGHT', 'NIGHT', 'CLOUD', 'BEACH'],
    hard: ['COMPUTER', 'ELEPHANT', 'BUTTERFLY', 'MOUNTAIN', 'KEYBOARD', 'RAINBOW', 'UNIVERSE', 'ADVENTURE', 'CHOCOLATE', 'TECHNOLOGY']
  };
  
  const difficulty = interaction.options.getString('difficulty') || 'medium';
  const wordList = words[difficulty] || words.medium;
  const word = wordList[Math.floor(Math.random() * wordList.length)];
  
  const gameId = `hangman_${interaction.user.id}_${Date.now()}`;
  
  activeGames.set(gameId, {
    type: 'hangman',
    word: word,
    guessedLetters: [],
    wrongGuesses: 0,
    maxWrongGuesses: 6,
    difficulty: difficulty,
    userId: interaction.user.id,
    channelId: interaction.channel.id,
    createdAt: Date.now()
  });
  
  let display = '_ '.repeat(word.length);
  
  await interaction.reply({
    embeds: [new EmbedBuilder()
      .setColor('#E67E22')
      .setTitle('üéØ Hangman Game')
      .setDescription('ƒêo√°n t·ª´ b·∫±ng c√°ch ƒëo√°n t·ª´ng ch·ªØ c√°i!')
      .addFields(
        { name: 'T·ª´', value: `\`${display}\`` },
        { name: 'ƒê·ªô kh√≥', value: difficulty, inline: true },
        { name: 'L∆∞·ª£t ƒëo√°n sai', value: '`0/6`', inline: true },
        { name: 'C√°ch ch∆°i', value: 'S·ª≠ d·ª•ng `/hangmanguess [ch·ªØ c√°i]` ƒë·ªÉ ƒëo√°n ch·ªØ c√°i' }
      )
      .setFooter({ text: `Game ID: ${gameId}` })
      .setTimestamp()]
  });
  
  stats.gamesPlayed++;
}

async function handleConnect4(interaction, { activeGames, stats }) {
  // (Gi·ªØ nguy√™n)
  const gameId = `connect4_${interaction.user.id}_${Date.now()}`;
  
  const grid = Array(6).fill(null).map(() => Array(7).fill('‚ö™')); // D√πng emoji
  
  activeGames.set(gameId, {
    type: 'connect4',
    grid: grid,
    currentPlayer: 'üî¥', // Player
    userId: interaction.user.id,
    channelId: interaction.channel.id,
    createdAt: Date.now()
  });
  
  let boardDisplay = grid.map(row => row.join(' ')).join('\n');
  boardDisplay += '\n1Ô∏è‚É£ 2Ô∏è‚É£ 3Ô∏è‚É£ 4Ô∏è‚É£ 5Ô∏è‚É£ 6Ô∏è‚É£ 7Ô∏è‚É£';
  
  const components = [];
  const row1 = new ActionRowBuilder();
  for (let c = 0; c < 7; c++) {
    row1.addComponents(
      new ButtonBuilder()
        .setCustomId(`connect4_${c}`)
        .setLabel(`${c + 1}`)
        .setStyle(ButtonStyle.Secondary)
    );
  }
  components.push(row1);
  
  await interaction.reply({
    embeds: [new EmbedBuilder()
      .setColor('#E74C3C')
      .setTitle('üî¥ Connect 4')
      .setDescription('B·∫°n l√† üî¥. Th·∫£ qu√¢n c·ªù c·ªßa b·∫°n!')
      .addFields(
        { name: 'B·∫£ng ch∆°i', value: boardDisplay }
      )
      .setFooter({ text: `Game ID: ${gameId}` })
      .setTimestamp()],
    components: components
  });
  
  stats.gamesPlayed++;
}

async function handleWeather(interaction, { getUserProfile, getWeather }) {
  const location = interaction.options.getString('location') || getUserProfile(interaction.user.id).weatherLocation;
  
  await interaction.deferReply();
  
  try {
    const weatherData = await getWeather(location);
    
    const iconUrl = `http://openweathermap.org/img/wn/${weatherData.icon}@2x.png`;
    
    await interaction.editReply({
      embeds: [new EmbedBuilder()
        .setColor('#3498DB')
        .setTitle(`üå§Ô∏è Th·ªùi ti·∫øt t·∫°i ${weatherData.location}, ${weatherData.country}`)
        .setThumbnail(iconUrl)
        .addFields(
          { name: 'üå° Nhi·ªát ƒë·ªô', value: `${weatherData.temperature}¬∞C (c·∫£m nh·∫≠n ${weatherData.feelsLike}¬∞C)`, inline: true },
          { name: 'üíß ƒê·ªô ·∫©m', value: `${weatherData.humidity}%`, inline: true },
          { name: 'üí® T·ªëc ƒë·ªô gi√≥', value: `${weatherData.windSpeed} m/s`, inline: true },
          { name: '‚òÅÔ∏è M√¥ t·∫£', value: weatherData.description, inline: false }
        )
        .setFooter({ text: `C·∫≠p nh·∫≠t: ${new Date(weatherData.timestamp).toLocaleString('vi-VN')}` })
        .setTimestamp()]
    });
  } catch (error) {
    await interaction.editReply(`‚ùå ${error.message}`);
  }
}

async function handleAdmin(interaction, { ADMIN_IDS, client, EmbedBuilder, ActivityType, conversationHistory }) {
  if (!ADMIN_IDS.includes(interaction.user.id)) {
    return interaction.reply({
      content: '‚ùå Ch·ªâ admin m·ªõi d√πng ƒë∆∞·ª£c l·ªánh n√†y!',
      ephemeral: true // C·∫¨P NH·∫¨T
    });
  }
  
  const subcommand = interaction.options.getSubcommand();
  
  switch (subcommand) {
    case 'clearall':
      conversationHistory.clear();
      await interaction.reply({ content: '‚úÖ ƒê√£ x√≥a t·∫•t c·∫£ l·ªãch s·ª≠ chat!', ephemeral: true });
      break;
      
    case 'broadcast':
      const message = interaction.options.getString('message');
      await interaction.reply({ content: 'ƒêang g·ª≠i broadcast...', ephemeral: true });

      const broadcastEmbed = new EmbedBuilder()
        .setColor('#FFD700')
        .setTitle('üì¢ Th√¥ng b√°o t·ª´ Admin')
        .setDescription(message)
        .setFooter({ text: 'Hein AI Bot' })
        .setTimestamp();

      let sentCount = 0;
      for (const guild of client.guilds.cache.values()) {
        // C·ªë g·∫Øng t√¨m k√™nh text ƒë·∫ßu ti√™n bot c√≥ th·ªÉ g·ª≠i tin
        const channel = guild.channels.cache.find(
          ch => ch.type === 0 && // 0 = GUILD_TEXT
          ch.permissionsFor(guild.members.me).has('SendMessages')
        );
        
        if (channel) {
          try {
            await channel.send({ embeds: [broadcastEmbed] });
            sentCount++;
          } catch (error) {
            console.error(`Failed to broadcast to ${guild.name}:`, error.message);
          }
        }
      }

      await interaction.followUp({ content: `‚úÖ ƒê√£ g·ª≠i broadcast ƒë·∫øn ${sentCount} / ${client.guilds.cache.size} servers!`, ephemeral: true });
      break;
      
    case 'setstatus':
      const status = interaction.options.getString('status');
      client.user.setActivity(status, { type: ActivityType.Playing });
      await interaction.reply({ content: `‚úÖ ƒê√£ ƒë·ªïi status: **${status}**`, ephemeral: true });
      break;
  }
}

async function handleHelp(interaction) {
  // (Gi·ªØ nguy√™n)
  const category = interaction.options.getString('category');
  
  if (!category) {
    await interaction.reply({
      embeds: [new EmbedBuilder()
        .setColor('#3498DB')
        .setTitle('üìö H∆∞·ªõng d·∫´n Hein AI Bot')
        .setDescription('Bot AI ƒëa nƒÉng v·ªõi nhi·ªÅu t√≠nh nƒÉng m·∫°nh m·∫Ω')
        .addFields(
          { name: 'üí¨ AI Chat', value: '`/chat` - Chat v·ªõi AI Hein' },
          { name: 'üé® T·∫°o ·∫£nh', value: '`/image` - T·∫°o ·∫£nh b·∫±ng AI\n`/imagine` - T·∫°o 4 phi√™n b·∫£n' },
          { name: 'üë§ H·ªì s∆° & Th·ªëng k√™', value: '`/profile` - Xem profile\n`/leaderboard` - B·∫£ng x·∫øp h·∫°ng\n`/stats` - Th·ªëng k√™ bot' },
          { name: 'üîß Ti·ªán √≠ch', value: '`/translate` - D·ªãch vƒÉn b·∫£n\n`/summary` - T√≥m t·∫Øt\n`/code` - T·∫°o code' },
          { name: 'üéÆ Gi·∫£i tr√≠', value: '`/quiz` - C√¢u h·ªèi tr·∫Øc nghi·ªám\n`/joke` - Chuy·ªán c∆∞·ªùi\n`/rps` - O·∫≥n t√π t√¨' },
          { name: 'üéÆ Tr√≤ ch∆°i m·ªõi', value: '`/memory` - Game nh·ªõ\n`/tictactoe` - C·ªù ca-r√¥\n`/trivia` - ƒê·ªë vui\n`/hangman` - Treo c·ªï\n`/connect4` - Connect 4' },
          { name: 'üå§Ô∏è Th·ªùi ti·∫øt', value: '`/weather` - Xem th√¥ng tin th·ªùi ti·∫øt' },
          { name: '‚öôÔ∏è C√†i ƒë·∫∑t', value: '`/personality` - ƒê·ªïi personality\n`/reset` - X√≥a l·ªãch s·ª≠' }
        )
        .setFooter({ text: 'S·ª≠ d·ª•ng /help [danh m·ª•c] ƒë·ªÉ xem chi ti·∫øt' })
        .setTimestamp()]
    });
    return;
  }
  
  let helpEmbed;
  
  switch (category) {
    case 'ai':
      helpEmbed = new EmbedBuilder()
        .setColor('#3498DB')
        .setTitle('üí¨ AI Chat Commands')
        .setDescription('C√°c l·ªánh ƒë·ªÉ tr√≤ chuy·ªán v·ªõi AI Hein')
        .addFields(
          { name: '`/chat [message]`', value: 'Tr√≤ chuy·ªán v·ªõi AI Hein' },
          { name: '`/personality [type]`', value: 'Ch·ªçn personality cho AI (default, creative, teacher, coder, funny)' },
          { name: '`/reset`', value: 'X√≥a l·ªãch s·ª≠ h·ªôi tho·∫°i' }
        )
        .setTimestamp();
      break;
      
    case 'image':
      helpEmbed = new EmbedBuilder()
        .setColor('#9B59B6')
        .setTitle('üé® Image Generation Commands')
        .setDescription('C√°c l·ªánh t·∫°o ·∫£nh b·∫±ng AI')
        .addFields(
          { name: '`/image [prompt] [style]`', value: 'T·∫°o ·∫£nh theo m√¥ t·∫£ v√† phong c√°ch' },
          { name: '`/imagine [prompt]`', value: 'T·∫°o 4 phi√™n b·∫£n ·∫£nh kh√°c nhau' }
        )
        .addFields(
          { name: 'C√°c style c√≥ s·∫µn', value: 'realistic, anime, cartoon, artistic, cyberpunk, fantasy' }
        )
        .setTimestamp();
      break;
      
    case 'profile':
      helpEmbed = new EmbedBuilder()
        .setColor('#2ECC71')
        .setTitle('üë§ Profile & Stats Commands')
        .setDescription('C√°c l·ªánh xem th√¥ng tin c√° nh√¢n v√† th·ªëng k√™')
        .addFields(
          { name: '`/profile`', value: 'Xem profile c·ªßa b·∫°n' },
          { name: '`/leaderboard`', value: 'Xem b·∫£ng x·∫øp h·∫°ng ng∆∞·ªùi d√πng' },
          { name: '`/stats`', value: 'Xem th·ªëng k√™ bot chi ti·∫øt' }
        )
        .setTimestamp();
      break;
      
    case 'utility':
      helpEmbed = new EmbedBuilder()
        .setColor('#E67E22')
        .setTitle('üîß Utility Commands')
        .setDescription('C√°c l·ªánh ti·ªán √≠ch h·ªØu √≠ch')
        .addFields(
          { name: '`/translate [text]`', value: 'D·ªãch vƒÉn b·∫£n Anh ‚Üî Vi·ªát' },
          { name: '`/summary [text]`', value: 'T√≥m t·∫Øt vƒÉn b·∫£n d√†i' },
          { name: '`/code [request]`', value: 'T·∫°o code theo y√™u c·∫ßu' },
          { name: '`/remind [time] [message]`', value: 'ƒê·∫∑t l·ªùi nh·∫Øc' }
        )
        .setTimestamp();
      break;
      
    case 'fun':
      helpEmbed = new EmbedBuilder()
        .setColor('#F39C12')
        .setTitle('üéÆ Fun Commands')
        .setDescription('C√°c l·ªánh gi·∫£i tr√≠')
        .addFields(
          { name: '`/quiz [topic]`', value: 'T·∫°o c√¢u h·ªèi tr·∫Øc nghi·ªám' },
          { name: '`/joke`', value: 'Nghe m·ªôt c√¢u chuy·ªán c∆∞·ªùi' },
          { name: '`/fact`', value: 'Xem m·ªôt s·ª± th·∫≠t th√∫ v·ªã' },
          { name: '`/roll [sides]`', value: 'Tung x√∫c x·∫Øc' },
          { name: '`/flip`', value: 'Tung ƒë·ªìng xu' },
          { name: '`/rps [choice]`', value: 'Ch∆°i o·∫≥n t√π t√¨' },
          { name: '`/numberguess`', value: 'Ch∆°i game ƒëo√°n s·ªë' },
          { name: '`/wordle`', value: 'Ch∆°i game Wordle' }
        )
        .setTimestamp();
      break;
      
    case 'games':
      helpEmbed = new EmbedBuilder()
        .setColor('#9B59B6')
        .setTitle('üéÆ Game Commands')
        .setDescription('C√°c l·ªánh ch∆°i game')
        .addFields(
          { name: '`/memory`', value: 'Game nh·ªõ - T√¨m c√°c c·∫∑p emoji gi·ªëng nhau (d√πng button)' },
          { name: '`/tictactoe`', value: 'C·ªù ca-r√¥ - Ch∆°i v·ªõi bot (d√πng button)' },
          { name: '`/trivia [category]`', value: 'ƒê·ªë vui - Tr·∫£ l·ªùi c√¢u h·ªèi ki·∫øn th·ª©c' },
          { name: '`/hangman [difficulty]`', value: 'Treo c·ªï - ƒêo√°n t·ª´ t·ª´ng ch·ªØ c√°i' },
          { name: '`/connect4`', value: 'Connect 4 - K·∫øt n·ªëi 4 qu√¢n c·ªù ƒë·ªÉ th·∫Øng (d√πng button)' }
        )
        .addFields(
          { name: 'L·ªánh h·ªó tr·ª£ game (c≈©)', value: '`/hangmanguess [ch·ªØ]` - ƒêo√°n ch·ªØ c√°i trong game treo c·ªï\n`/guess [s·ªë]` - ƒêo√°n s·ªë\n`/wordleguess [t·ª´]` - ƒêo√°n t·ª´ Wordle' }
        )
        .setTimestamp();
      break;
      
    case 'admin':
      helpEmbed = new EmbedBuilder()
        .setColor('#E74C3C')
        .setTitle('‚öôÔ∏è Admin Commands')
        .setDescription('C√°c l·ªánh d√†nh cho admin')
        .addFields(
          { name: '`/admin clearall`', value: 'X√≥a t·∫•t c·∫£ l·ªãch s·ª≠ d√πng chat' },
          { name: '`/admin broadcast [message]`', value: 'G·ª≠i th√¥ng b√°o to√†n bot' },
          { name: '`/admin setstatus [status]`', value: 'ƒê·ªïi status bot' },
          { name: '`/provider [name]`', value: 'ƒê·ªïi AI provider (openrouter, gemini, openai)' }
        )
        .setTimestamp();
      break;
      
    default:
      helpEmbed = new EmbedBuilder()
        .setColor('#95A5A6')
        .setTitle('‚ùì Kh√¥ng t√¨m th·∫•y danh m·ª•c')
        .setDescription('Danh m·ª•c kh√¥ng t·ªìn t·∫°i. Vui l√≤ng th·ª≠ l·∫°i.');
      break;
  }
  
  await interaction.reply({ embeds: [helpEmbed], ephemeral: true });
}

// =GETIC-NH·∫¨T: D√πng findActiveGame
async function handleGuessCommand(message, { activeGames }) {
  const guessValue = message.content.substring(7).trim();
  const guess = parseInt(guessValue);
  
  if (isNaN(guess) || guess < 1 || guess > 100) {
    return message.reply('‚ùå Vui l√≤ng nh·∫≠p m·ªôt s·ªë t·ª´ 1-100!');
  }
  
  const gameData = findActiveGame(activeGames, message.author.id, message.channel.id, 'numberguess');
  
  if (!gameData) {
    return message.reply('‚ùå B·∫°n ch∆∞a b·∫Øt ƒë·∫ßu game ƒëo√°n s·ªë! S·ª≠ d·ª•ng `/numberguess` ƒë·ªÉ b·∫Øt ƒë·∫ßu.');
  }

  const { gameId, game } = gameData;
  game.attempts++;
  
  let result;
  if (guess === game.number) {
    result = `üéâ Ch√≠nh x√°c! S·ªë l√† ${game.number}! B·∫°n ƒë√£ ƒëo√°n ƒë√∫ng sau ${game.attempts} l·∫ßn!`;
    activeGames.delete(gameId);
  } else if (guess < game.number) {
    result = `üìà S·ªë ${guess} qu√° th·∫•p!`;
  } else {
    result = `üìâ S·ªë ${guess} qu√° cao!`;
  }
  
  if (game.attempts >= game.maxAttempts && guess !== game.number) {
    result += `\n\n‚ùå H·∫øt l∆∞·ª£t ƒëo√°n! S·ªë ƒë√∫ng l√† ${game.number}.`;
    activeGames.delete(gameId);
  } else if (guess !== game.number) {
    result += ` B·∫°n c√≤n ${game.maxAttempts - game.attempts} l∆∞·ª£t.`;
  }
  
  await message.reply(result);
}

// C·∫¨P NH·∫¨T: D√πng findActiveGame
async function handleWordleGuessCommand(message, { activeGames }) {
  const guess = message.content.substring(13).trim().toUpperCase();
  
  if (guess.length !== 5 || !/^[A-Z]+$/.test(guess)) {
    return message.reply('‚ùå Vui l√≤ng nh·∫≠p m·ªôt t·ª´ ti·∫øng Anh 5 ch·ªØ c√°i!');
  }
  
  const gameData = findActiveGame(activeGames, message.author.id, message.channel.id, 'wordle');

  if (!gameData) {
    return message.reply('‚ùå B·∫°n ch∆∞a b·∫Øt ƒë·∫ßu game Wordle! S·ª≠ d·ª•ng `/wordle` ƒë·ªÉ b·∫Øt ƒë·∫ßu.');
  }

  const { gameId, game } = gameData;
  game.attempts.push(guess);
  
  // Logic ki·ªÉm tra Wordle
  const wordleCheck = (guess, target) => {
    let result = ['‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ', '‚¨õ'];
    let targetChars = target.split('');

    // Check üü© (ƒë√∫ng v·ªã tr√≠)
    for (let i = 0; i < 5; i++) {
      if (guess[i] === target[i]) {
        result[i] = 'üü©';
        targetChars[i] = null; // ƒê√°nh d·∫•u ƒë√£ d√πng
      }
    }

    // Check üü® (sai v·ªã tr√≠)
    for (let i = 0; i < 5; i++) {
      if (result[i] === '‚¨õ') { // Ch·ªâ check ch·ªØ ch∆∞a ƒë√∫ng
        const charIndex = targetChars.indexOf(guess[i]);
        if (charIndex !== -1) {
          result[i] = 'üü®';
          targetChars[charIndex] = null; // ƒê√°nh d·∫•u ƒë√£ d√πng
        }
      }
    }
    return result.join('');
  };
  
  const attemptsText = game.attempts.map(a => 
    `${a} ${wordleCheck(a, game.word)}`
  ).join('\n');
  
  let response = `\n${attemptsText}`;
  
  if (guess === game.word) {
    response += `\n\nüéâ Ch√∫c m·ª´ng! B·∫°n ƒë√£ ƒëo√°n ƒë√∫ng t·ª´ **${game.word}** sau ${game.attempts.length} l·∫ßn!`;
    activeGames.delete(gameId);
  } else if (game.attempts.length >= game.maxAttempts) {
    response += `\n\n‚ùå H·∫øt l∆∞·ª£t ƒëo√°n! T·ª´ ƒë√∫ng l√† **${game.word}**.`;
    activeGames.delete(gameId);
  } else {
    response += `\n\nB·∫°n c√≤n ${game.maxAttempts - game.attempts.length} l∆∞·ª£t.`;
  }
  
  await message.reply(response);
}

// C·∫¨P NH·∫¨T: D√πng findActiveGame
async function handleMemoryFlipCommand(message, { activeGames }) {
  // L·ªánh n√†y kh√¥ng c√≤n d√πng n·ªØa v√¨ ƒë√£ chuy·ªÉn sang button, nh∆∞ng gi·ªØ l·∫°i
  const cardIndex = parseInt(message.content.substring(13).trim()) - 1;
  
  if (isNaN(cardIndex) || cardIndex < 0 || cardIndex > 15) {
    return message.reply('‚ùå Vui l√≤ng nh·∫≠p m·ªôt s·ªë t·ª´ 1-16! (L∆∞u √Ω: Game n√†y ƒë√£ chuy·ªÉn sang d√πng Button)');
  }
  
  const gameData = findActiveGame(activeGames, message.author.id, message.channel.id, 'memory');
  if (!gameData) {
    return message.reply('‚ùå B·∫°n ch∆∞a b·∫Øt ƒë·∫ßu game Memory! S·ª≠ d·ª•ng `/memory` ƒë·ªÉ b·∫Øt ƒë·∫ßu.');
  }
  // Logic game (ƒë√£ chuy·ªÉn sang handleButtonInteraction)
  await message.reply('Vui l√≤ng nh·∫•n v√†o c√°c button tr√™n m√†n h√¨nh game.');
}

// C·∫¨P NH·∫¨T: D√πng findActiveGame
async function handleHangmanGuessCommand(message, { activeGames }) {
  const letter = message.content.substring(16).trim().toUpperCase();
  
  if (!/^[A-Z]$/.test(letter)) {
    return message.reply('‚ùå Vui l√≤ng nh·∫≠p m·ªôt ch·ªØ c√°i t·ª´ A-Z!');
  }
  
  const gameData = findActiveGame(activeGames, message.author.id, message.channel.id, 'hangman');

  if (!gameData) {
    return message.reply('‚ùå B·∫°n ch∆∞a b·∫Øt ƒë·∫ßu game Hangman! S·ª≠ d·ª•ng `/hangman` ƒë·ªÉ b·∫Øt ƒë·∫ßu.');
  }

  const { gameId, game } = gameData;
  
  if (game.guessedLetters.includes(letter)) {
    return message.reply('‚ùå B·∫°n ƒë√£ ƒëo√°n ch·ªØ c√°i n√†y r·ªìi!');
  }
  
  game.guessedLetters.push(letter);
  
  let display = '';
  let correctGuess = false;
  let wordComplete = true;

  for (const char of game.word) {
    if (game.guessedLetters.includes(char)) {
      display += `${char} `;
      if (char === letter) correctGuess = true;
    } else {
      display += '_ ';
      wordComplete = false;
    }
  }
  
  if (!correctGuess) {
    game.wrongGuesses++;
  }
  
  const hangmanDisplay = [
    '```\n \n \n \n \n \n=========\n```',
    '```\n  +---+\n  |   |\n      |\n      |\n      |\n      |\n=========\n```',
    '```\n  +---+\n  |   |\n  O   |\n      |\n      |\n      |\n=========\n```',
    '```\n  +---+\n  |   |\n  O   |\n  |   |\n      |\n      |\n=========\n```',
    '```\n  +---+\n  |   |\n  O   |\n /|   |\n      |\n      |\n=========\n```',
    '```\n  +---+\n  |   |\n  O   |\n /|\\  |\n      |\n      |\n=========\n```',
    '```\n  +---+\n  |   |\n  O   |\n /|\\  |\n / \\  |\n      |\n=========\n```'
  ][game.wrongGuesses];
  
  let gameStatus = '';
  if (wordComplete) {
    gameStatus = `üéâ Ch√∫c m·ª´ng! B·∫°n ƒë√£ ƒëo√°n ƒë√∫ng t·ª´ **${game.word}**!`;
    activeGames.delete(gameId);
  } else if (game.wrongGuesses >= game.maxWrongGuesses) {
    gameStatus = `‚ùå B·∫°n ƒë√£ thua! T·ª´ ƒë√∫ng l√† **${game.word}**.`;
    activeGames.delete(gameId);
  } else {
    gameStatus = `B·∫°n c√≤n ${game.maxWrongGuesses - game.wrongGuesses} l∆∞·ª£t ƒëo√°n sai.`;
  }
  
  await message.reply({
    embeds: [new EmbedBuilder()
      .setColor(wordComplete ? '#00FF00' : (game.wrongGuesses >= game.maxWrongGuesses ? '#FF0000' : '#E67E22'))
      .setTitle('üéØ Hangman Game')
      .setDescription(gameStatus)
      .addFields(
        { name: 'T·ª´', value: `\`${display}\`` },
        { name: 'Ch·ªØ c√°i ƒë√£ ƒëo√°n', value: game.guessedLetters.join(', ') || 'Ch∆∞a c√≥' },
        { name: 'H√¨nh ·∫£nh', value: hangmanDisplay }
      )
      .setFooter({ text: `Game ID: ${gameId}` })
      .setTimestamp()]
  });
}

// C·∫¨P NH·∫¨T: T√°i c·∫•u tr√∫c logic t√¨m game
async function handleButtonInteraction(interaction, { activeGames }) {
  const customId = interaction.customId;
  
  let gameType = null;
  if (customId.startsWith('tictactoe_')) gameType = 'tictactoe';
  if (customId.startsWith('connect4_')) gameType = 'connect4';
  if (customId.startsWith('memory_')) gameType = 'memory';

  if (!gameType) return; // Kh√¥ng ph·∫£i button game

  const gameData = findActiveGame(activeGames, interaction.user.id, interaction.channel.id, gameType);

  if (!gameData) {
    return interaction.reply({
      content: `‚ùå Kh√¥ng t√¨m th·∫•y game ${gameType} ƒëang ho·∫°t ƒë·ªông! Vui l√≤ng b·∫Øt ƒë·∫ßu game m·ªõi.`,
      ephemeral: true
    });
  }

  const { gameId, game } = gameData;
  
  // ====================
  //  LOGIC TICTACTOE
  // ====================
  if (gameType === 'tictactoe') {
    const position = parseInt(customId.split('_')[1]);
    
    if (game.board[position] !== '') {
      return interaction.reply({ content: '‚ùå √î n√†y ƒë√£ ƒë∆∞·ª£c ƒë√°nh!', ephemeral: true });
    }
    
    // Player's move
    game.board[position] = 'X';
    
    let result = checkWin(game.board, 'X') ? 'player' : (game.board.includes('') ? null : 'draw');
    
    // Bot's move (if game not over)
    if (!result) {
      const availablePositions = [];
      for (let i = 0; i < 9; i++) {
        if (game.board[i] === '') availablePositions.push(i);
      }
      
      const botPosition = availablePositions[Math.floor(Math.random() * availablePositions.length)];
      game.board[botPosition] = 'O';
      
      result = checkWin(game.board, 'O') ? 'bot' : (game.board.includes('') ? null : 'draw');
    }
    
    // C·∫≠p nh·∫≠t buttons
    const components = [];
    for (let r = 0; r < 3; r++) {
      const row = new ActionRowBuilder();
      for (let c = 0; c < 3; c++) {
        const index = r * 3 + c;
        const label = game.board[index] || ' ';
        let style = ButtonStyle.Secondary;
        if (label === 'X') style = ButtonStyle.Success;
        if (label === 'O') style = ButtonStyle.Danger;
        
        row.addComponents(
          new ButtonBuilder()
            .setCustomId(`tictactoe_${index}`)
            .setLabel(label)
            .setStyle(style)
            .setDisabled(true) // V√¥ hi·ªáu h√≥a t·∫•t c·∫£ n·∫øu game k·∫øt th√∫c, ho·∫∑c √¥ ƒë√£ ƒë√°nh
        );
      }
      components.push(row);
    }

    // C·∫≠p nh·∫≠t embed
    const embed = new EmbedBuilder()
      .setColor('#3498DB')
      .setTitle('‚≠ï Tic Tac Toe')
      .setFooter({ text: `Game ID: ${gameId}` })
      .setTimestamp();

    if (result === 'player') {
      embed.setColor('#00FF00').setDescription('üéâ B·∫°n th·∫Øng!');
      activeGames.delete(gameId);
    } else if (result === 'bot') {
      embed.setColor('#FF0000').setDescription('üíÄ Bot th·∫Øng!');
      activeGames.delete(gameId);
    } else if (result === 'draw') {
      embed.setColor('#FFD700').setDescription('ü§ù H√≤a!');
      activeGames.delete(gameId);
    } else {
      embed.setDescription('L∆∞·ª£t c·ªßa b·∫°n (X)');
      // K√≠ch ho·∫°t l·∫°i c√°c √¥ tr·ªëng
      components.forEach(row => {
        row.components.forEach((button, i) => {
          if (button.data.label === ' ') button.setDisabled(false);
        });
      });
    }

    await interaction.update({ embeds: [embed], components: components });
    return;
  }

  // ====================
  //  LOGIC CONNECT4
  // ====================
  if (gameType === 'connect4') {
    if (customId === 'connect4_reset') {
        // (Logic reset - gi·ªØ nguy√™n t·ª´ code g·ªëc c·ªßa b·∫°n)
        // ... (n√™n chuy·ªÉn logic n√†y ra ngo√†i)
        await interaction.update({ content: 'Game ƒë√£ ƒë∆∞·ª£c reset!', embeds: [], components: [] });
        activeGames.delete(gameId);
        await handleConnect4(interaction, { activeGames, stats: { gamesPlayed: 0 } }); // H∆°i hack, c·∫ßn s·ª≠a l·∫°i
        return;
    }
    
    const column = parseInt(customId.split('_')[1]);
    
    // T√¨m √¥ tr·ªëng th·∫•p nh·∫•t
    let rowPosition = -1;
    for (let r = 5; r >= 0; r--) {
      if (game.grid[r][column] === '‚ö™') {
        rowPosition = r;
        break;
      }
    }

    if (rowPosition === -1) {
      return interaction.reply({ content: '‚ùå C·ªôt n√†y ƒë√£ ƒë·∫ßy!', ephemeral: true });
    }

    // Player's move
    game.grid[rowPosition][column] = 'üî¥';
    let result = checkConnect4Win(game.grid, 'üî¥') ? 'player' : null;

    // Bot's move
    if (!result) {
      // (Logic bot's move - gi·ªØ nguy√™n t·ª´ code g·ªëc c·ªßa b·∫°n, nh∆∞ng c·∫ßn check draw)
      // ... (Th√™m logic bot)
      
      // T·∫°m th·ªùi: Bot random
      const availableColumns = [];
      for (let c = 0; c < 7; c++) {
        if (game.grid[0][c] === '‚ö™') availableColumns.push(c);
      }
      
      if (availableColumns.length > 0) {
        const botColumn = availableColumns[Math.floor(Math.random() * availableColumns.length)];
        let botRow = -1;
        for (let r = 5; r >= 0; r--) {
            if (game.grid[r][botColumn] === '‚ö™') {
                botRow = r;
                break;
            }
        }
        game.grid[botRow][botColumn] = 'üîµ';
        result = checkConnect4Win(game.grid, 'üîµ') ? 'bot' : null;
      } else {
        result = 'draw'; // H·∫øt c·ªôt
      }
    }

    // C·∫≠p nh·∫≠t board
    let boardDisplay = game.grid.map(row => row.join(' ')).join('\n');
    boardDisplay += '\n1Ô∏è‚É£ 2Ô∏è‚É£ 3Ô∏è‚É£ 4Ô∏è‚É£ 5Ô∏è‚É£ 6Ô∏è‚É£ 7Ô∏è‚É£';

    const embed = new EmbedBuilder()
      .setColor('#E74C3C')
      .setTitle('üî¥ Connect 4')
      .addFields({ name: 'B·∫£ng ch∆°i', value: boardDisplay })
      .setFooter({ text: `Game ID: ${gameId}` })
      .setTimestamp();
    
    const components = interaction.message.components;
    
    if (result === 'player') {
      embed.setColor('#00FF00').setDescription('üéâ B·∫°n th·∫Øng!');
      activeGames.delete(gameId);
      components.forEach(row => row.components.forEach(btn => btn.setDisabled(true)));
    } else if (result === 'bot') {
      embed.setColor('#FF0000').setDescription('üíÄ Bot th·∫Øng!');
      activeGames.delete(gameId);
      components.forEach(row => row.components.forEach(btn => btn.setDisabled(true)));
    } else if (result === 'draw') {
      embed.setColor('#FFD700').setDescription('ü§ù H√≤a!');
      activeGames.delete(gameId);
      components.forEach(row => row.components.forEach(btn => btn.setDisabled(true)));
    } else {
      embed.setDescription('L∆∞·ª£t c·ªßa b·∫°n (üî¥)');
      // V√¥ hi·ªáu h√≥a c·ªôt ƒë√£ ƒë·∫ßy
      components[0].components.forEach((btn, c) => {
        if (game.grid[0][c] !== '‚ö™') btn.setDisabled(true);
      });
    }

    await interaction.update({ embeds: [embed], components: components });
    return;
  }

  // ====================
  //  LOGIC MEMORY
  // ====================
  if (gameType === 'memory') {
    const index = parseInt(customId.split('_')[1]);

    if (game.matched[index] || game.revealed.includes(index)) {
      return interaction.reply({ content: '‚ùå Th·∫ª n√†y ƒë√£ ƒë∆∞·ª£c l·∫≠t!', ephemeral: true });
    }

    game.revealed.push(index);
    game.attempts++;

    let updateComponents = interaction.message.components.map(row => ActionRowBuilder.from(row));
    let r = Math.floor(index / 4);
    let c = index % 4;
    updateComponents[r].components[c].setLabel(game.cards[index]).setStyle(ButtonStyle.Primary).setDisabled(true);

    if (game.revealed.length === 2) {
      // Hai th·∫ª ƒë√£ l·∫≠t
      const [index1, index2] = game.revealed;
      const card1 = game.cards[index1];
      const card2 = game.cards[index2];

      if (card1 === card2) {
        // TR√ôNG KH·ªöP
        game.matched[index1] = true;
        game.matched[index2] = true;
        game.revealed = [];

        let r1 = Math.floor(index1 / 4), c1 = index1 % 4;
        let r2 = Math.floor(index2 / 4), c2 = index2 % 4;
        updateComponents[r1].components[c1].setStyle(ButtonStyle.Success).setDisabled(true);
        updateComponents[r2].components[c2].setStyle(ButtonStyle.Success).setDisabled(true);
        
        // Check th·∫Øng
        if (game.matched.every(m => m === true)) {
          activeGames.delete(gameId);
          await interaction.update({
            embeds: [new EmbedBuilder().setColor('#00FF00').setTitle('üéâ B·∫°n th·∫Øng!').setDescription(`B·∫°n ƒë√£ ho√†n th√†nh sau ${game.attempts} l∆∞·ª£t l·∫≠t!`)],
            components: updateComponents
          });
          return;
        }

        await interaction.update({ components: updateComponents });

      } else {
        // KH√îNG KH·ªöP
        let r1 = Math.floor(index1 / 4), c1 = index1 % 4;
        let r2 = Math.floor(index2 / 4), c2 = index2 % 4;
        updateComponents[r1].components[c1].setStyle(ButtonStyle.Danger);
        updateComponents[r2].components[c2].setStyle(ButtonStyle.Danger);
        
        await interaction.update({ components: updateComponents });

        // √öp th·∫ª l·∫°i sau 1.5s
        setTimeout(async () => {
          game.revealed = [];
          updateComponents[r1].components[c1].setLabel('‚ùì').setStyle(ButtonStyle.Secondary).setDisabled(false);
          updateComponents[r2].components[c2].setLabel('‚ùì').setStyle(ButtonStyle.Secondary).setDisabled(false);
          // C·∫ßn fetch l·∫°i message ƒë·ªÉ update, v√¨ interaction c√≥ th·ªÉ ƒë√£ h·∫øt h·∫°n
          await interaction.editReply({ components: updateComponents }).catch(console.error);
        }, 1500);
      }
    } else {
      // M·ªõi l·∫≠t 1 th·∫ª
      await interaction.update({ components: updateComponents });
    }
    return;
  }
}

// (C√°c h√†m helper checkWin v√† checkConnect4Win gi·ªØ nguy√™n)
function checkWin(board, player) {
  const winConditions = [
    [0, 1, 2], [3, 4, 5], [6, 7, 8], // Rows
    [0, 3, 6], [1, 4, 7], [2, 5, 8], // Columns
    [0, 4, 8], [2, 4, 6]  // Diagonals
  ];
  return winConditions.some(condition => 
    condition.every(index => board[index] === player)
  );
}

function checkConnect4Win(grid, player) {
  // Check horizontal
  for (let r = 0; r < 6; r++) {
    for (let c = 0; c < 4; c++) {
      if (grid[r][c] === player && grid[r][c + 1] === player && grid[r][c + 2] === player && grid[r][c + 3] === player) {
        return true;
      }
    }
  }
  // Check vertical
  for (let r = 0; r < 3; r++) {
    for (let c = 0; c < 7; c++) {
      if (grid[r][c] === player && grid[r + 1][c] === player && grid[r + 2][c] === player && grid[r + 3][c] === player) {
        return true;
      }
    }
  }
  // Check diagonal (down-right)
  for (let r = 0; r < 3; r++) {
    for (let c = 0; c < 4; c++) {
      if (grid[r][c] === player && grid[r + 1][c + 1] === player && grid[r + 2][c + 2] === player && grid[r + 3][c + 3] === player) {
        return true;
      }
    }
  }
  // Check diagonal (up-right)
  for (let r = 3; r < 6; r++) {
    for (let c = 0; c < 4; c++) {
      if (grid[r][c] === player && grid[r - 1][c + 1] === player && grid[r - 2][c + 2] === player && grid[r - 3][c + 3] === player) {
        return true;
      }
    }
  }
  return false;
}

module.exports = {
  handleChat,
  handleReset,
  handlePersonality,
  handleImage,
  handleImagine,
  handleProfile,
  handleLeaderboard,
  handleStats,
  handleTranslate,
  handleSummary,
  handleCode,
  handleQuiz,
  handleJoke,
  handleFact,
  handleRemind,
  handleRoll,
  handleFlip,
  handleRPS,
  handleNumberGuess,
  handleWordle,
  handleMemoryGame,
  handleTicTacToe,
  handleTrivia,
  handleHangman,
  handleConnect4,
  handleWeather,
  handleAdmin,
  handleHelp,
  handleGuessCommand,
  handleWordleGuessCommand,
  handleMemoryFlipCommand,
  handleHangmanGuessCommand,
  handleButtonInteraction
};
